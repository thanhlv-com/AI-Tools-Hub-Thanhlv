import { CapacityResult, FieldCapacityDetail, TableCapacityBreakdown } from '@/types/capacity';

export interface ConfluenceExportOptions {
  includeFieldDetails: boolean;
  includeRecommendations: boolean;
  includeOverheadAnalysis: boolean;
  tableName?: string;
}

export function formatBytesToHumanReadable(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
}

export function generateConfluenceWikiMarkup(
  result: CapacityResult,
  ddl: string,
  databaseType: string,
  recordCount: number,
  options: ConfluenceExportOptions = {
    includeFieldDetails: true,
    includeRecommendations: true,
    includeOverheadAnalysis: true
  }
): string {
  const timestamp = new Date().toLocaleString('vi-VN');
  
  let confluenceMarkup = `h1. Database Capacity Analysis Report

|| *Database Type* | ${databaseType.toUpperCase()} |
|| *Record Count* | ${recordCount.toLocaleString()} |
|| *Analysis Date* | ${timestamp} |

h2. Executive Summary

|| *Metric* || *Average Case* || *Maximum Case* ||
| Record Size | ${formatBytesToHumanReadable(result.averageRecordSize)} | ${formatBytesToHumanReadable(result.maximumRecordSize)} |
| Total Data Size | ${formatBytesToHumanReadable(result.totalSizeAverage.bytes)} ({color:blue}${result.totalSizeAverage.mb.toFixed(2)} MB{color}) | ${formatBytesToHumanReadable(result.totalSizeMaximum.bytes)} ({color:red}${result.totalSizeMaximum.mb.toFixed(2)} MB{color}) |`;

  if (result.indexSize) {
    confluenceMarkup += `
| Index Size | {color:purple}${formatBytesToHumanReadable(result.indexSize.bytes)} (${result.indexSize.mb.toFixed(2)} MB){color} | {color:purple}${formatBytesToHumanReadable(result.indexSize.bytes)} (${result.indexSize.mb.toFixed(2)} MB){color} |`;
  }

  if (result.totalWithIndexAverage && result.totalWithIndexMaximum) {
    confluenceMarkup += `
| Total with Index | {color:green}${formatBytesToHumanReadable(result.totalWithIndexAverage.bytes)} (${result.totalWithIndexAverage.mb.toFixed(2)} MB){color} | {color:orange}${formatBytesToHumanReadable(result.totalWithIndexMaximum.bytes)} (${result.totalWithIndexMaximum.mb.toFixed(2)} MB){color} |`;
  }

  confluenceMarkup += `

h2. Table Breakdown Analysis

`;

  // Table breakdown
  if (result.breakdown && result.breakdown.length > 0) {
    for (const table of result.breakdown) {
      confluenceMarkup += generateTableBreakdown(table, options);
    }
  }

  // Recommendations
  if (options.includeRecommendations && result.recommendations && result.recommendations.length > 0) {
    confluenceMarkup += `
h2. Optimization Recommendations

`;
    result.recommendations.forEach((rec, index) => {
      confluenceMarkup += `# ${rec}
`;
    });
  }

  // DDL Schema
  confluenceMarkup += `
h2. DDL Schema

{code:sql}
${ddl}
{code}

---
*Report generated by AI Database Capacity Analyzer*
*Timestamp: ${timestamp}*
`;

  return confluenceMarkup;
}

function generateTableBreakdown(table: TableCapacityBreakdown, options: ConfluenceExportOptions): string {
  let markup = `h3. Table: \`${table.tableName}\`

|| *Metric* || *Average* || *Maximum* ||
| Record Size | ${formatBytesToHumanReadable(table.averageRecordSize)} | ${formatBytesToHumanReadable(table.maximumRecordSize)} |
| Total Size | ${formatBytesToHumanReadable(table.totalSizeAverage.bytes)} (${table.totalSizeAverage.mb.toFixed(2)} MB) | ${formatBytesToHumanReadable(table.totalSizeMaximum.bytes)} (${table.totalSizeMaximum.mb.toFixed(2)} MB) |
| Record Count | {color:blue}${table.recordCount.toLocaleString()}{color} | {color:blue}${table.recordCount.toLocaleString()}{color} |
`;

  if (table.indexSize) {
    markup += `| Index Size | ${formatBytesToHumanReadable(table.indexSize.bytes)} (${table.indexSize.mb.toFixed(2)} MB) | ${formatBytesToHumanReadable(table.indexSize.bytes)} (${table.indexSize.mb.toFixed(2)} MB) |
`;
  }

  // Field details
  if (options.includeFieldDetails && table.fieldDetails && table.fieldDetails.length > 0) {
    markup += `
h4. Field-Level Capacity Analysis

|| *Field Name* || *Data Type* || *Nullable* || *Avg Size* || *Max Size* || *Overhead* || *Description* ||
`;
    table.fieldDetails.forEach(field => {
      const nullableIcon = field.nullable ? '{color:orange}✓{color}' : '{color:green}✗{color}';
      markup += `| \`${field.fieldName}\` | \`${field.dataType}\` | ${nullableIcon} | ${formatBytesToHumanReadable(field.averageSize)} | ${formatBytesToHumanReadable(field.maximumSize)} | ${formatBytesToHumanReadable(field.overhead)} | ${field.description} |
`;
    });
  }

  // Row overhead analysis
  if (options.includeOverheadAnalysis && table.rowOverhead) {
    markup += `
h4. Row Overhead Analysis

|| *Component* || *Size* || *Description* ||
| Null Bitmap | ${formatBytesToHumanReadable(table.rowOverhead.nullBitmap)} | Tracks NULL values for nullable columns |
| Row Header | ${formatBytesToHumanReadable(table.rowOverhead.rowHeader)} | Database engine metadata |
| Alignment Padding | ${formatBytesToHumanReadable(table.rowOverhead.alignment)} | Memory alignment requirements |
| {color:red}*Total Overhead*{color} | {color:red}*${formatBytesToHumanReadable(table.rowOverhead.total)}*{color} | {color:red}*Per-record system overhead*{color} |
`;
  }

  // Table-specific recommendations
  if (options.includeRecommendations && table.recommendations && table.recommendations.length > 0) {
    markup += `
h4. Table-Specific Recommendations

`;
    table.recommendations.forEach((rec, index) => {
      markup += `* ${rec}
`;
    });
  }

  markup += `
`;
  return markup;
}

export function generateFieldAnalysisMarkup(fields: FieldCapacityDetail[]): string {
  let markup = `h2. Detailed Field Analysis

`;

  fields.forEach(field => {
    markup += `h3. Field: \`${field.fieldName}\`

|| *Property* || *Value* ||
| Data Type | \`${field.dataType}\` |
| Max Length | ${field.maxLength ? field.maxLength.toLocaleString() : 'N/A'} |
| Nullable | ${field.nullable ? '{color:orange}Yes{color}' : '{color:green}No{color}'} |
| Average Size | {color:blue}${formatBytesToHumanReadable(field.averageSize)}{color} |
| Maximum Size | {color:red}${formatBytesToHumanReadable(field.maximumSize)}{color} |
| Overhead | {color:gray}${formatBytesToHumanReadable(field.overhead)}{color} |

{panel:title=Storage Analysis}
${field.description}
${field.storageNotes ? `

*Additional Notes:* ${field.storageNotes}` : ''}
{panel}

`;
  });

  return markup;
}

export function generateSummaryTable(result: CapacityResult, recordCount: number): string {
  const avgPerRecord = result.totalSizeAverage.bytes / recordCount;
  const maxPerRecord = result.totalSizeMaximum.bytes / recordCount;
  
  return `|| *Storage Capacity Summary* ||
|| Total Records || ${recordCount.toLocaleString()} ||
|| Average per Record || ${formatBytesToHumanReadable(avgPerRecord)} ||
|| Maximum per Record || ${formatBytesToHumanReadable(maxPerRecord)} ||
|| Total Average Storage || {color:blue}${formatBytesToHumanReadable(result.totalSizeAverage.bytes)} (${result.totalSizeAverage.gb.toFixed(3)} GB){color} ||
|| Total Maximum Storage || {color:red}${formatBytesToHumanReadable(result.totalSizeMaximum.bytes)} (${result.totalSizeMaximum.gb.toFixed(3)} GB){color} ||
|| Storage Range || ${formatBytesToHumanReadable(result.totalSizeMaximum.bytes - result.totalSizeAverage.bytes)} difference ||`;
}